VFP Legacy Code Documentation Requirements Specification
1. PROJECT OVERVIEW
1.1 Project Name
Visual FoxPro Legacy Code Documentation Automation System
1.2 Primary Objective
Transform undocumented Visual FoxPro (.prg and .spr) legacy code files into comprehensively commented versions that enable developers unfamiliar with VFP to understand the code's functionality, business logic, and purpose.
1.3 Target Audience

Modern developers who need to maintain VFP legacy systems
Development teams transitioning from VFP to modern languages
New team members who need to understand existing VFP codebase
Technical documentation teams

1.4 Current Situation

Codebase Size: 2,190 VFP files (64.3 MB) across multiple nested directories
Problem: No documentation or comments in legacy code
Challenge: VFP expertise is rare; modern developers struggle to understand the code
Solution: Automated commenting using AI while preserving original code integrity

2. TECHNICAL SPECIFICATIONS
2.1 File Processing

Input Files: .prg, .PRG, .spr, .SPR extensions
Output Files: Same directory, with "_commented" suffix (e.g., file.prg â†’ file_commented.prg)
Directory Structure: Maintains exact original structure
Processing: Recursive through all subdirectories

2.2 Technology Stack

Language: Python 3.8+
AI Model: Local LLM (GPTOSS20B) via LM Studio
API Endpoint: OpenAI-compatible format at http://127.0.0.1:1234/v1/chat/completions
Processing Mode: Single-threaded, one file at a time for safety

2.3 Critical Constraints

ABSOLUTE REQUIREMENT: Original code must NEVER be modified
Validation: Multiple layers of code preservation validation
Safety: Hash comparison, line-by-line validation, atomic file operations
Recovery: Session persistence for resumable processing

3. COMMENTING STYLE REQUIREMENTS
3.1 Header Comment Block
Every file must start with a comprehensive header containing:
foxpro* ===================================================================
* Program: [filename with extension]
* Purpose: [Brief description of what this program/procedure does]
* 
* [Extended description of the program's role in the system]
* [Business context and why this program exists]
*
* Parameters: (if applicable)
*   param1 - [Type and purpose]
*   param2 - [Type and purpose]
*
* Returns: [What the program returns, if applicable]
*
* Dependencies:
*   - [List of called programs, external files, or requirements]
*
* Database Tables: [List tables accessed/modified]
*
* Key Business Logic:
*   - [Summary of main business rules implemented]
* ===================================================================
3.2 Section Comments
Before each logical code section, add explanatory comments:
foxpro* ===== Section Purpose =====
* [Explanation of what this section does]
* [Why it's needed in the workflow]
* [Any important side effects or state changes]
3.3 Code Block Comments
Place comments ABOVE code blocks (not inline for multi-line explanations):
foxpro* Validate prescription reference: must be a non-empty character value
* If invalid, notify user appropriately based on call context
IF EMPTY(cRefNo) OR NOT (VARTYPE(cRefNo)="C")
    * Handle different notification methods based on invocation context
    IF cCallType<>"BACK GROUND"
        MESSAGEBOX("Empty or Invalid Prescription No",64,"")
    ELSE
        WAIT WINDOW "Empty or Invalid Prescription No" TIMEOUT 3
    ENDIF
    RETURN "FAILED"
ENDIF
3.4 Inline Comments
Use sparingly, only for critical single-line clarifications:
foxproLOCAL lcName, lnAge  && Declare variables for person information
lcName = "John Doe"  && Set default name
3.5 Business Logic Documentation
Explain business rules in plain English:
foxpro* Check if purchase qualifies for premium discount
* Business Rule: Customers spending over $1000 receive 10% discount
* This implements the company's tiered pricing strategy
IF lnAmount > 1000
    lnDiscount = lnAmount * 0.10
3.6 Database Operations
Document all database interactions:
foxpro* Fetch prescription header row for this reference into cursor 'CurChk'
* This retrieves: prescription number, patient ID, doctor ID, status, type, and contact info
* The data is used to validate the prescription and determine processing path
nRec=oSql.SELECT("select prscrp_no,patient_no,doctor_id,ePStatus,ePType,ePMobileEmail from prscrphd where prscrp_no='"+ALLTRIM(cRefNo)+"'","CurChk")
3.7 Error Handling
Document error scenarios and recovery:
foxpro* Handle missing prescription: if no rows found, inform user based on context
* Background processes use WAIT WINDOW for non-blocking notification
* Interactive processes use MESSAGEBOX for user acknowledgment
IF nRec<=0
    IF cCallType<>"BACK GROUND"
        MESSAGEBOX("Invalid Prescription No",64,"")
    ELSE
        WAIT WINDOW "Invalid Prescription No" TIMEOUT 3
    ENDIF
4. SPECIFIC EXAMPLES FROM CODEBASE
4.1 Example Input (Original)
foxproLPARAMETERS cRefNo, cCallType
IF EMPTY(cCallType) OR VARTYPE(cCallType)<>"C"
	cCallType="ON DEMAND"
ENDIF

IF EMPTY(cRefNo) OR NOT (VARTYPE(cRefNo)="C")
	IF cCallType<>"BACK GROUND"
		MESSAGEBOX("Empty or Invalid Prescription No",64,"")
	ELSE
		WAIT WINDOW "Empty or Invalid Prescription No" TIMEOUT 3
	ENDIF
	RETURN "FAILED"
ENDIF
4.2 Example Output (Commented)
foxpro* Program to send ePrescription for given Ref No via external executable, validate inputs, run, and update status.
* Parameters: cRefNo = prescription reference number; cCallType = invocation context (e.g., 'ON DEMAND', 'BACK GROUND').

LPARAMETERS cRefNo, cCallType

* Normalize call type: default to 'ON DEMAND' if not provided or not character.
IF EMPTY(cCallType) OR VARTYPE(cCallType)<>"C"
  cCallType="ON DEMAND"
ENDIF

* Validate prescription reference: must be a non-empty character value; otherwise notify user and exit as FAILED.
IF EMPTY(cRefNo) OR NOT (VARTYPE(cRefNo)="C")
  IF cCallType<>"BACK GROUND"
    MESSAGEBOX("Empty or Invalid Prescription No",64,"")
  ELSE
    WAIT WINDOW "Empty or Invalid Prescription No" TIMEOUT 3
  ENDIF
  
  * Return final result to caller (e.g., 'SUCCESS' or 'FAILED').
  RETURN "FAILED"
ENDIF
5. DOCUMENTATION PRIORITIES
5.1 Must Document

Program Purpose: What problem does this code solve?
Business Logic: Why are decisions made this way?
Data Flow: Where does data come from and where does it go?
Side Effects: What changes occur in database/files/state?
Error Handling: What can go wrong and how is it handled?
Parameters/Returns: What goes in and what comes out?
External Dependencies: What else does this code rely on?

5.2 Documentation Style

Write for developers who don't know VFP syntax
Explain business context, not just technical operations
Use clear, concise English without VFP jargon
Group related operations with section comments
Explain the "why" not just the "what"

6. VALIDATION REQUIREMENTS
6.1 Code Preservation

Hash Validation: SHA-256 hash of code lines must match before/after
Line Count: Exact same number of code lines (excluding comments)
Line-by-Line: Each original code line must be identical
No Modifications: Zero tolerance for any code changes

6.2 Comment Quality

Every file must have a header comment block
Complex logic blocks must have explanatory comments
Database operations must be documented
Business rules must be explained in plain English
Error handling paths must be documented

7. PROCESSING WORKFLOW
7.1 File Processing Steps

Read original VFP file
Send to LLM with strict commenting instructions
Receive commented version
Validate code preservation (multiple checks)
If validation fails, retry with stronger emphasis
Save commented file in same directory
Log results and update progress

7.2 Batch Processing

Process files one at a time for maximum safety
Track progress by folder and overall
Support resume capability for interrupted sessions
Generate comprehensive reports

8. SPECIAL CONSIDERATIONS
8.1 VFP-Specific Elements to Document

PARAMETERS/LPARAMETERS: Document each parameter's purpose and type
LOCAL/PUBLIC variables: Explain what each stores and why
Cursors: Document temporary data structures and their purpose
SQL statements: Explain what data is retrieved/modified
File operations: Document file I/O and paths
MESSAGEBOX/WAIT WINDOW: Explain user interactions
RETURN values: Document what's returned and why

8.2 Business Context

Medical/Healthcare context: This is a medical system (prescriptions, patients, doctors)
Workflow understanding: Document the business process flow
Regulatory compliance: Note any compliance-related logic
Integration points: Document external system interactions

9. OUTPUT QUALITY CRITERIA
9.1 Successful Output Characteristics

Original code 100% preserved
Comprehensive header explaining program purpose
Business logic explained in plain English
All parameters and returns documented
Database operations clearly explained
Error handling paths documented
Comments placed appropriately (above blocks, not cluttering code)

9.2 Unacceptable Output

Any modification to original code
Generic/unhelpful comments ("This is a loop")
Missing header documentation
Unexplained business logic
Inline comments that clutter the code
Technical jargon without explanation

10. PROJECT SUCCESS METRICS
10.1 Quantitative Metrics

100% code preservation rate (zero modifications)
All 2,190 VFP files processed
< 5% failure rate in processing
Average 30-60 seconds per file processing time

10.2 Qualitative Metrics

Developers can understand code purpose without VFP knowledge
Business logic is clearly documented
Code maintenance becomes feasible for non-VFP developers
Knowledge transfer from legacy system is preserved

11. EXAMPLE PATTERNS TO RECOGNIZE AND DOCUMENT
11.1 Database Patterns
foxpro* Pattern: SQL SELECT into cursor
* Document: What data is retrieved, from which table, for what purpose
oSql.SELECT("select...", "CursorName")
11.2 Validation Patterns
foxpro* Pattern: Parameter validation
* Document: What's being validated, acceptable values, failure behavior
IF EMPTY(param) OR VARTYPE(param)<>"C"
11.3 Business Logic Patterns
foxpro* Pattern: Conditional business rules
* Document: The business rule, thresholds, and actions taken
IF amount > threshold
    * Apply discount/penalty/special handling
ENDIF
11.4 Error Handling Patterns
foxpro* Pattern: Try-catch equivalent
* Document: What errors are expected, recovery strategy
IF error_condition
    * Handle error
    RETURN "FAILED"
ENDIF
12. PROMPT GENERATION REQUIREMENTS
When generating prompts for the LLM, ensure:

Emphasize code preservation as the top priority
Request educational comments for non-VFP developers
Specify comment placement (above blocks, not inline for explanations)
Include examples from actual commented files
Focus on business logic explanation over syntax
Request comprehensive headers for every file
Emphasize the "why" behind code decisions

13. FINAL DELIVERABLE
The system must produce VFP files where:

Every file has a clear purpose statement
Every business decision is explained
Every database operation is documented
Every error path is clear
A developer with no VFP knowledge can understand what the code does
The original code is 100% preserved without any modifications